---------------- Get random value ----------------------
const getRandomValue = (min, max) => {
    return Math.floor(Math.random() * (max-min)) + min
}
------------------array---------------
list:[]
list.push('a')     -> them vao cuoi
list.unshift('a')  -> them vao dau
list.splice(index) -> remove item at index position

--------------------
new Date().toISOString() -> create id

--------test number--------
/^\d+$/.test(number) --> return boolean

---------web component example---------------
https://codepen.io/bradtraversy/pen/wvaXKoK

--------svg note-------------
<svg viewBox="0 0 100 100">
  <rect
    x="10" y="10" width="20%" height="20" fill="red" stroke="blue"
  />
  <path d="M 10 30 l 0 20 l 20 0"></path>
  <path d="M 10 60 C 20 80, 40 80, 50 60"></path>
</svg>

var shape = document.querySelector('.square');
var shapeLength = shape.getTotalLenght();
----------tbl width example--------
https://brainbell.com/javascript/making-resizable-table-js.html
-----header fixed----
document.getElementById("wrap").addEventListener("scroll", function(){
   var translate = "translate(0,"+this.scrollTop+"px)";
   this.querySelector("thead").style.transform = translate;
});
------------drag and drop ----------
https://htmldom.dev/drag-and-drop-table-column/
-----virtual dom example---
https://github.com/ycmjason-talks/2018-11-21-manc-web-meetup-4/tree/master/src/vdom
--------Add event Listen-----------
e.addEventListener('click',e => {
    e.stopPropagation() // stop capture and bubble
},{capture: true} // {once:true})

document
document capture
grandparent capture
parent capture
child capture
child bubble
parent bubble
grandparent bubble
document bubble

document.addEventListener('click',e => {
    if(e.target.matches("div")){
        console.log("zz")
    }
})
-----------tabindex------------
*[tabindex]:focus {
    outline: 2px green solid;
}
*:focus {
   outline: blue solid 2px;
}
div:focus {outline: blue solid 2px;}
------console style-------
console.log(`%c ${a} %c$ {b}`,"font-weight:bold","color:green")
-----optional chaining-------
obj?.prop1?.prop2
obj.fnc?.()
obj.arr?.[idx]
----defer-----
----pointer event------
el.addEventListener("pointerdown",e => {
    el.setPointerCapture(e.pointerId)
    setPosition(e)
    el.addEventListener("pointermove",setPosition)
    el.addEventListener("pointerup",() => {
        // el.releasePointerCapture(e.pointerId)
        // el.hasPointerCapture(e.pointerId)
        el.removeEventListener("pointermove",setPosition)
    },{once:true})
})
---- arr to obj-------
const obj = arr.reduce((acc,word) => {acc[word]=word;return acc;},{})
---- Regexpression---
const regex = new RegExp('^.a.$')
regex.test('cat')
------sleep--------
const sleep = (duration) => {
    return new Promise(resolve => {
        setTimeout(resolve,duration)
    })
};
sleep(200).then(()=>{})
----randomNumberBetween----
const fnc = (min,max) => {return Math.floor(Math.random()*(max-min+1)+min);};
------debounce----------
function debounce(cb,delay=1000){
    let timeout
    return (...args) => {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
            cb(...args)
        },delay)
    }
}
------throttle---------
function throttle(cb, delay=1000){
    let shouldWait = false
    let waitingArgs
    const timeoutFnc = () => {
        if(waitingArgs == null){
            shouldWait = false
        }else{
            cb(...waitingArgs)
            waitingArgs = null
            setTimeout(timeoutFnc,delay)
        }
    }
    return (...args) => {
        if (shouldWait){
            waitingArgs = args
            return
        }
        cb(...args)
        shouldWait = true
        setTimeout(timeoutFnc,delay)
    }
}
--------ResizeObserver------
const observer = new ResizeObserver(entries => {console.log(entries)})
observer.observe(element1)
observer.observe(element2)
--------MutationObserver------
observer.observe(parent,{
    childList:true,
    attributes:true,attributeOldValue:true,attributeFilter:["id"],
    subtree:true,characterData:true,characterDataOldValue:true
})
observer.disconnect()
--------IntersectionObserver------
---scrollbar calc----
var arrowHeight = 25;
var viewportHeight = 200;
var contentHeight = 600;
var viewableRatio = viewportHeight / contentHeight; // 1/3 or 0.333333333n
var scrollBarArea = viewportHeight - arrowHeight * 2; // 150px
var thumbHeight = scrollBarArea * viewableRatio; // 50px
----web component --------------
----slot style
::slot(cssSelectorOnlyTop){
}
::slot(*){
}
:host
:host-context(p){
}
----attr change
attributeChangedCallback(name, oldValue, newValue){
    console.log(name, oldValue, newValue);
}
static get observedAttributes(){
    return ['text']
}
------promise-------
let p = new Promise((resolve,reject) => {
    let a = 1 + 1
    if(a ==2) {
        resolve('success')
    }else{
        reject('fail')
    }
})
p.then((message) => {
    console.log(message) // success
}).catch((message)=>{
    console.log(message) // fail
})

Promise.all([p1,p2,p3]).then((messageArr)=>{console.log(messageArr)}).catch((messageArr)=>{console.log(messageArr)})

----------fetch ping---------
fetch('https://www.google.com/', {
    method: 'HEAD',
    mode: 'no-cors'
  })
  .then((response) => {
    console.log("connected");
  }, (err) => {
    console.log("error: " + err); // (currently fetch failed)
  })
------ajax ping------
//       function pingURL() {
//          // Getting the URL from the User
//          var URL = $("#url").val();
//          var settings = {
//             // Defining the request configuration
//             cache: false,
//             dataType: "jsonp",
//             crossDomain: true,
//             url: URL,
//             method: "GET",
//             timeout: 5000,
//             headers: {accept: "application/json", "Access-Control-Allow-Origin": "*",},

//             // Defines the response to be made
//             // for certain status codes
//             statusCode: {
//                200: function (response) {
//                   document.getElementById("outputDiv").innerHTML="<h3 style='color:green'>Status 200: Page is up!";
//                },
//                400: function (response) {
//                   document.getElementById("outputDiv").innerHTML="<h3 style='color:red'>Status 400: Page is down.</h3>";
//                },
//                0: function (response) {
//                   document.getElementById("outputDiv").innerHTML="<h3 style='color:red'>Status 0: Page is down.</h3>";
//                },
//             },
//          };
//          // Sends the request and observes the response
//          $.ajax(settings).done(function (response) {
//             console.log(response);
//          })
//          .fail(function (response) {
//             console.log("Error" + response);
//          });
//       }
//       function jsonp(url, callback) {
//     var callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());
//     window[callbackName] = function(data) {
//         delete window[callbackName];
//         document.body.removeChild(script);
//         callback(data);
//     };

//     var script = document.createElement('script');
//     script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + callbackName;
//     document.body.appendChild(script);
// }
